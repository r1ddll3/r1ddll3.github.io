---
title: "Analyze - SkullLocker Ransomware"
date: 2023-03-11T06:53:09+02:00
draft: true
tags: ["Malware Analysis", "Reverse engineering", "SkullLocker"]
author: "@R1ddl3"
# author: ["Me", "You"] # multiple authors
showToc: false
TocOpen: false
draft: false
hidemeta: false
comments: true
description: "Full Analysis - SkullLocker"
disableHLJS: true # to disable highlightjs
disableShare: false
hideSummary: false
searchHidden: false
ShowReadingTime: true
ShowBreadCrumbs: true
ShowPostNavLinks: true
ShowWordCount: true
ShowRssButtonInSectionTermList: true
UseHugoToc: true
cover:
    image: "https://www.2-viruses.com/wp-content/uploads/2017/07/SkullLocker-Screenlocker-virus.png" # image path/url
    alt: "SkullLocker Ransomware" # alt text
    caption: "<text>" # display caption under cover
    relative: false # when using page bundles set this to true
    hidden: true # only hide on current single page
---
## Analyze - SkullLockerRansomware
**SkullLocker** is a new variant of the Chaos ransomware family. Ransomware is spread using various techniques such as spam emails and fake torrent sites. This particular type of ransomware encrypts files and adds a ".skull" extension to filenames. 

## Overview

The malware is coded using .NET we can determine that using Detect it easy(DiE) Tool: ![enter image description here](https://i.imgur.com/p7vCn2p.png)

## Code analysis

The malware doesn't come packed or something we can just decompile it using `dnSpy` and start analyzing the code and see its behavior and capabilities. 

At the beginning the malware defines some variables which the author can edit and customize the malware like, (Message, processName, spreadName and Ransomware text message)
```
userName = Environment.UserName;

userDir = "C:\\Users\\";

appMutexRun = "7z459ajrk722yn8c5j4fg";

encryptionAesRsa = true;

encryptedFileExtension = "skull";

checkSpread = true;

spreadName = "skull.exe";

checkCopyRoaming = true;

processName = "svchost.exe";

appMutexRun2 = "2X28tfRmWaPyPQgvoHV";

checkStartupFolder = true;

checkSleep = true;

sleepTextbox = 10;

base64Image = "#base64Image";

appMutexStartup = "1qw0ll8p9m8uezhqhyd";

droppedMessageTextbox = "read_it.txt";

checkAdminPrivilage = true;

checkdeleteShadowCopies = true;

checkdisableRecoveryMode = true;

checkdeleteBackupCatalog = true;

appMutexStartup2 = "17CqMQFeuB3NTzJ";

appMutex2 = Program.appMutexStartup2 + Program.appMutexRun2;

staticSplit = "bc";

appMutex = Program.staticSplit + Program.appMutexStartup + Program.appMutexRun;
```
### Already Running

![enter image description here](https://i.imgur.com/pYKSKcF.png)
First, the malware defines a method called `AlreadyRunning` which checks if there is already an instance of the current process running.

The method first uses `Process.GetProcesses()` to get a list of all currently running processes. It then uses `Process.GetCurrentProcess()` to get a reference to the current process.

The method then iterates through each of the processes in the list and checks if the first module in the process's module collection has the same file name as the current executing assembly(Malware), which is obtained using `Assembly.GetExecutingAssembly().Location`, `Assembly.GetExecutingAssembly().Location` will return the full path of the malware.

If a process is found that matches these conditions, the method returns true and the application will exit. If no matching process is found, the method returns false.
### Check Admin Privilege
```
if  (Program.checkAdminPrivilage)  
{  
	Program.copyResistForAdmin(Program.processName);  
}
```
If we take a look at `copyResistForAdmin` method 
![enter image description here](https://i.imgur.com/ZET0yD3.png)
`private  static  string  processName  =  "svchost.exe";`
We know that the `processName` is `svchost.exe` so this method attempts to copy the current executable to a location within the user's `/AppData/Roaming/` folder using a filename of `svchost.exe`. Since `svchost.exe` is a legitimate system process, this an attempt by malware to disguise itself as a legitimate system process and avoid detection. Once the malware has copied itself to the new location and is running as an `administrator`, it could use this `persistence mechanism` to remain undetected and ensure that the malware can persist on the victim's machine even after a system reboot or shutdown and if an exception occurs when attempting to start the new `process` with elevated privileges (the user declines the UAC prompt), the method recursively calls itself using the same `processName` argument.
### addLinkToStartup
![enter image description here](https://i.imgur.com/M0DnAhb.png)
This code defines a static method called `addLinkToStartup` that adds a shortcut to the current executable to `%USERPROFILE%\AppData\Roaming\Microsoft\Windows\Start Menu` and the name of the shortcut is `svchost.url`. This method essentially ensures that the current executable will run every time the user logs into the system, making it a persistence mechanism.

### Encrypt Directories
This method is responsible for encrypting directories in the given location.
![enter image description here](https://i.imgur.com/mw6rW3i.png)
if we take a look at `lookForDirectories` 
![enter image description here](https://i.imgur.com/BvQWni3.png)
and it calls method named `encryptDirectory` and this method  gets a list of all files in the given location using `.GetFiles` function, then loops through each file and this 
`if (Array.Exists<string>(Program.validExtensions, (string E) => E == extension.ToLower()) && fileName != Program.droppedMessageTextbox)` checks if the file extension is in the `validExtensions` array and is not the `droppedMessageTextbox` and we know that `droppedMessageTextbox = "read_it.txt";` and this file `read_it.txt` has the message that the victim sees after the encryption process finished. And these are the targeted folders
![enter image description here](https://i.imgur.com/XL5MaZ3.png) Also these are the `validExtensions`
```
".txt",".jar",".dat",".contact",".settings",".doc",".docx",".xls",".xlsx",".ppt",".pptx",".odt",".jpg",".mka",".mhtml",".oqy",".png",".csv",".py",".sql",".mdb",".php",".asp",".aspx",".html",".htm",".xml",".psd",".pdf",".xla",".cub",".dae",".indd",".cs",".mp3",".mp4",".dwg",".zip",".rar",".mov",".rtf",".bmp",".mkv",".avi",".apk",".lnk",".dib",".dic",".dif",".divx",".iso",".7zip",".ace",".arj",".bz2",".cab",".gzip",".lzh",".tar",".jpeg",".xz",".mpeg",".torrent",".mpg",".core",".pdb",".ico",".pas",".db",".wmv",".swf",".cer",".bak",".backup",".accdb",".bay",".p7c",".exif",".vss",".raw",".m4a",".wma",".flv",".sie",".sum",".ibank",".wallet",".css",".js",".rb",".crt",".xlsm",".xlsb",".7z",".cpp",".java",".jpe",".ini",".blob",".wps",".docm",".wav",".3gp",".webm",".m4v",".amv",".m4p",".svg",".ods",".bk",".vdi",".vmdk",".onepkg",".accde",".jsp",".json",".gif",".log",".gz",".config",".vb",".m1v",".sln",".pst",".obj",".xlam",".djvu",".inc",".cvs",".dbf",".tbi",".wpd",".dot",".dotx",".xltx",".pptm",".potx",".potm",".pot",".xlw",".xps",".xsd",".xsf",".xsl",".kmz",".accdr",".stm",".accdt",".ppam",".pps",".ppsm",".1cd",".3ds",".3fr",".3g2",".accda",".accdc",".accdw",".adp",".ai",".ai3",".ai4",".ai5",".ai6",".ai7",".ai8",".arw",".ascx",".asm",".asmx",".avs",".bin",".cfm",".dbx",".dcm",".dcr",".pict",".rgbe",".dwt",".f4v",".exr",".kwm",".max",".mda",".mde",".mdf",".mdw",".mht",".mpv",".msg",".myi",".nef",".odc",".geo",".swift",".odm",".odp",".oft",".orf",".pfx",".p12",".pl",".pls",".safe",".tab",".vbs",".xlk",".xlm",".xlt",".xltm",".svgz",".slk",".tar.gz",".dmg",".ps",".psb",".tif",".rss",".key",".vob",".epsp",".dc3",".iff",".onepkg",".onetoc2",".opt",".p7b",".pam",".r3d"
```
if the file size is less than 2MB it is encrypted using the `EncryptFile` method and if the size is bigger than 200 MB
a random string of a random length between 200000000 and 300000000 bytes is generated and encoded using the `randomEncode` method after that, the original file  renamed to a random 4-character extension using `RandomStringForExtension`.
### Encrypt File
![enter image description here](https://i.imgur.com/vkSDLz8.png)
used to encrypt a file using `AES encryption algorithm` with a randomly generated password. The method reads the contents of the file into a byte array, generates a random password using the `CreatePassword` method, and converts the password to a byte array using UTF8 encoding. The method then writes the encrypted key and the encrypted content to the file. The encrypted key is the RSA encrypted random password generated earlier, and the `encrypted content` is the output of the `AES encryption`. Both of these are concatenated and written to the file using the `File.WriteAllText` method.
Finally, the method renames the original file by appending a random extension using the `RandomStringForExtension` method

### Registry Startup

![enter image description here](https://i.imgur.com/4MZRTFp.png)

This method adds the path of the current executable to the Windows registry `SOFTWARE\Microsoft\Windows\CurrentVersion\Run`  named `Microsoft Store` also used for persistence.

### Spread It
![enter image description here](https://i.imgur.com/oIZWjkk.png)
`private  static  string  spreadName  =  "skull.exe";`
This code is responsible for spreading the malware to other drives on the victim's machine. It loops through all the available drives on the system using the `DriveInfo.GetDrives()` method and checks if the drive is not the `C:\` drive and if a file with the `spreadName` doesn't exist in that drive. If both conditions are true, it copies the malware's executable file to that drive with the specified `spreadName`. This way, the malware can potentially infect other machines or systems that are connected to those drives.

### Malware Message
![enter image description here](https://i.imgur.com/4Ozgy53.png)

This code is responsible for creating a file with `droppedMessageTextbox` value and we already know the name of the file `private  static  string  droppedMessageTextbox  =  "read_it.txt";` and then write the content of the `Program.messages` value into it and then open the file to the victim to let him know that his files have been encrypted. The message variable written in polish translate it by yourself :D
![enter image description here](https://i.imgur.com/rafqPBx.png)
```
Witaj,
Twoje pliki zostały zaszyfrowane przez SkullLocker ransomware. Aby odzyskać dostęp do nich musizapłacić okup w ciągu 72 godzin. W przeciwnym razie dane zostaną trwale utracone.
			
Aby uzyskać więcej informacji na temat sposobu zapłaty okupu i odzyskiwania plików przejdź na stronę internetową podaną poniżej.
			
U6cQ2nV4KzL3H8jxSdGhTfMlR0N1wX7eJbO9mZyIaP5pgqWvEoBkYtAxDsFi.onion
			
Jeśli masz jakiekolwiek pytania możesz skontaktować się z nami za pomocą adresu e-mail [adres e-mail].
			
Nie próbuj usuwać programu ransomware ani próbować odzyskać danych za pomocą oprogramowania antywirusowego. Może to spowodować trwałe uszkodzenie Twoich plików.
			
Pamiętaj że czas jest kluczowy. Im dłużej zwlekasz tym mniejsze szanse na odzyskanie Twoich plików.
			
Pozdrawiamy
Zespół ransomware
```
### Ransom Wallet Addresses

![enter image description here](https://i.imgur.com/AuOd1lr.png)

The code first reads the current contents of the clipboard using a method called `GetText` from a `NotificationForm` object. If the clipboard text starts with the string "bc1", the code seems to be manipulating the contents of the clipboard to ensure that certain strings are present or replaced with specific values and the values are stored in `appMutex2` and `appMutex` if we went back to the variables that at the beginning we will notice that `appMutex  =  Program.staticSplit  +  Program.appMutexStartup  +  Program.appMutexRun;`and `appMutex2  =  Program.appMutexStartup2  +  Program.appMutexRun2;`after we concatenate these values together we will get `2 Bitcoin Wallets` ![enter image description here](https://i.imgur.com/mKLm6jR.png)

So, using Threat Intel we can determine if there is wallet with this address by going to Blockchain.
![enter image description here](https://i.imgur.com/AWShbgI.png)

### Change Wallpaper
![enter image description here](https://i.imgur.com/JvQQEye.png)
First `base64Image` has the base64 of the wallpaper then it attempts to write the decoded bytes to a temporary file with a random name and a ".jpg" extension. Then, it calls the `SystemParametersInfo` function with the parameters `20U (indicating that the desktop wallpaper should be changed)`,` 0U (indicating that the wallpaper should be changed immediately)`, the path to the temporary file, and `3U (indicating that the wallpaper should be tiled)`.

### Delete Shadow Copies
```
private  static  void  deleteShadowCopies()  
{  
	Program.runCommand("vssadmin delete shadows /all /quiet & wmic shadowcopy delete");  
}
```
This code invokes two command-line tools, `vssadmin` and `wmic`, to delete all the existing shadow copies on the victim's machine. The code is effectively preventing the victim from restoring their data using the shadow copies.

### Delete backup

```
private  static  void  deleteBackupCatalog()  
{  
	Program.runCommand("wbadmin delete catalog -quiet");  
}
```
This command is used to delete the backup catalog on a local Windows computer without prompting the user for confirmation.

## Mapping to MITRE

|ID| Tactics |Technique|Description|
|--|--|--|--|
|T1547.001  | Persistence, Privilege Escalation  | Boot or Logon Autostart Execution| Adversaries may achieve persistence by adding a program to a startup folder or referencing it with a Registry run key. Adding an entry to the "run keys" in the Registry or startup folder will cause the program referenced to be executed when a user logs in. These programs will be executed under the context of the user and will have the account's associated permissions level. Placing a program within a startup folder will also cause that program to execute when a user logs in. There is a startup folder location for individual user accounts as well as a system-wide startup folder that will be checked regardless of which user account logs in. The startup folder path for the current user is C:\Users\[Username]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup  
| T1037.005  |  Persistence, Privilege Escalation | Boot or Logon Initialization Scripts  |    Adversaries may use scripts automatically executed at boot or logon initialization to establish persistence. Initialization scripts can be used to perform administrative functions, which may often execute other programs or send information to an internal logging server. These scripts can vary based on operating system and whether applied locally or remotely.  
|T1027 | Defense Evasion | Obfuscated Files or Information | Encode data using Base64, Encrypt data using AES via .NET
| T1070.004  | Defense Evasion | Indicator Removal: File Deletion  |  Adversaries may delete files left behind by the actions of their intrusion activity. Deletes the backup plan of Windows, Deletes shadow drive data (related to ransomware) 
| T1471  | Impact  | Data Encrypted for Impact  | The adversary is trying to manipulate, interrupt, or destroy your devices and data and hold it for ransom

## IOCs
| Indicator Type| Value |
| --- | --- |
| SHA256 | bb5ca9d8de51734dbd14dc081c7c892d819cd14fafd7ccd62849d70f9e679369 |

## Yara Rule
	

	rule skull_locker {
	    meta:
	        author = "R1ddl3"
	        description = "Yara rule for detecting SkullLocker Ransomware"
	        hash = "bb5ca9d8de51734dbd14dc081c7c892d819cd14fafd7ccd62849d70f9e679369"
	    strings:
	        $mz = { 4D 5A }           // PE file
	        $str1 = "skull.exe"
	        $str2 = "checkCopyRoaming"
	        $str3 = "appMutexRegex"
	        $str4 = "copyResistForAdmin"
	        $str5 = "deleteShadowCopies"
	        $str6 = "lookForDirectories"
	        $str7 = "spreadIt"
	        $str8 = "appMutexRun2"
	        $str9 = "appMutexRun"
	        $str10 = "checkSpread"

	    condition:
	        ($mz at 0) and (4 of ($str*)) and (hash.sha256() == $hash or not $hash)
	}



-- Thanks for reading, hope you enjoyed.